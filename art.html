<script>
const canvas = document.getElementById("vines");
const ctx = canvas.getContext("2d");

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener("resize", resize);

// fake mouse "size"
const mouse = { x: 0, y: 0, w: 18, h: 18 };
window.addEventListener("mousemove", e => {
  mouse.x = e.clientX;
  mouse.y = e.clientY;
});

const GRAVITY = 0.35;
const FRICTION = 0.995;
const SEGMENTS = 22;
const SEG_LENGTH = 10;
const VINE_COLOR = "#00ff33";

ctx.imageSmoothingEnabled = false;

class Point {
  constructor(x, y, pinned = false) {
    this.x = x;
    this.y = y;
    this.oldx = x;
    this.oldy = y;
    this.pinned = pinned;
    this.offset = (Math.random() - 0.5) * 2;
  }

  update() {
    if (this.pinned) return;

    let vx = (this.x - this.oldx) * FRICTION;
    let vy = (this.y - this.oldy) * FRICTION;

    this.oldx = this.x;
    this.oldy = this.y;

    this.x += vx;
    this.y += vy + GRAVITY;

    // rectangular mouse collision
    if (
      this.x > mouse.x - mouse.w &&
      this.x < mouse.x + mouse.w &&
      this.y > mouse.y - mouse.h &&
      this.y < mouse.y + mouse.h
    ) {
      this.x += vx * 3;
      this.y -= 2;
    }
  }
}

class Vine {
  constructor(x) {
    this.points = [];
    for (let i = 0; i < SEGMENTS; i++) {
      this.points.push(
        new Point(x, i * SEG_LENGTH, i === 0)
      );
    }
  }

  update() {
    this.points.forEach(p => p.update());
    for (let i = 0; i < 6; i++) this.constrain();
  }

  constrain() {
    for (let i = 0; i < this.points.length - 1; i++) {
      const p1 = this.points[i];
      const p2 = this.points[i + 1];

      const dx = p2.x - p1.x;
      const dy = p2.y - p1.y;
      const dist = Math.hypot(dx, dy);
      const diff = (SEG_LENGTH - dist) / dist * 0.5;

      if (!p1.pinned) {
        p1.x -= dx * diff;
        p1.y -= dy * diff;
      }
      p2.x += dx * diff;
      p2.y += dy * diff;
    }
  }

  draw() {
    ctx.fillStyle = VINE_COLOR;

    for (let i = 0; i < this.points.length - 1; i++) {
      const p = this.points[i];

      // pixel snap + organic wobble
      const px = Math.round(p.x + p.offset);
      const py = Math.round(p.y);

      ctx.fillRect(px, py, 4, 4);

      // occasional side pixels = vine texture
      if (i % 3 === 0) {
        ctx.fil
